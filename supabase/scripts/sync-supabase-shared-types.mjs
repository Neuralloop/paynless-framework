import fs from 'node:fs/promises';
import path from 'node:path';
import { fileURLToPath } from 'node:url';

// Helper function to get the directory name of the current module
const __filename = fileURLToPath(import.meta.url);
const __dirname = path.dirname(__filename);

// --- Configuration ---

// Base directory of the monorepo (adjust if script location changes)
const MONOREPO_ROOT = path.resolve(__dirname, '../../'); 

// Source directory for application-level types
const SOURCE_TYPES_DIR = path.join(MONOREPO_ROOT, 'packages', 'types', 'src');

// Target file within supabase/functions
const TARGET_SHARED_TYPES_FILE = path.join(MONOREPO_ROOT, 'supabase', 'functions', '_shared', 'types.ts');

// Define which types to extract from which source files
const TYPES_TO_SYNC = {
    // Format: 'target_type_name': 'source_file_relative_to_SOURCE_TYPES_DIR'
    'UserData': 'email.types.ts',
    'EmailMarketingService': 'email.types.ts',
    'CheckoutSessionRequest': 'subscription.types.ts',
    'BillingPortalRequest': 'subscription.types.ts',
    'SessionResponse': 'subscription.types.ts',
    'ApiSubscriptionUsageMetrics': 'subscription.types.ts',
    'ChatApiRequest': 'ai.types.ts',
    'ProviderModelInfo': 'ai.types.ts',
    'AiProviderAdapter': 'ai.types.ts',
    // Add any other necessary application-level types here
};

const FILE_HEADER = `// supabase/functions/_shared/types.ts
// !!! THIS FILE IS AUTO-GENERATED BY scripts/sync-supabase-shared-types.mjs !!!
// !!! DO NOT EDIT DIRECTLY !!!
//
// Contains APPLICATION-LEVEL types needed by Supabase Edge Functions,
// copied from the main @paynless/types package.
// Types directly related to DB tables should be imported from ../types_db.ts
`;

// --- Script Logic ---

async function extractTypeDefinition(sourceFilePath, typeName) {
    try {
        const content = await fs.readFile(sourceFilePath, 'utf-8');
        // Use regex to find exported interface or type alias
        // This is a basic regex and might need refinement for complex cases (e.g., multi-line generics)
        const regex = new RegExp(`export\s+(?:interface|type)\s+${typeName}\s*(?:<[^>]+>)?\s*=?\s*({[^}]*}|[^;]+);?`, 's');
        const match = content.match(regex);
        
        if (match && match[0]) {
            console.log(`   [OK] Found definition for ${typeName}`);
            // Return the full matched definition block
            return match[0].trim();
        } else {
            console.warn(`   [WARN] Definition not found for ${typeName} in ${path.basename(sourceFilePath)}`);
            return null;
        }
    } catch (error) {
        console.error(`   [ERROR] Failed to read or parse ${sourceFilePath}:`, error);
        return null;
    }
}

async function main() {
    console.log("Starting sync of shared types to supabase/functions/_shared/types.ts...");

    let outputContent = FILE_HEADER + '\n';
    let typesFound = 0;
    const typesToExtract = Object.entries(TYPES_TO_SYNC);

    for (const [typeName, sourceFile] of typesToExtract) {
        console.log(` - Processing ${typeName} from ${sourceFile}...`);
        const sourceFilePath = path.join(SOURCE_TYPES_DIR, sourceFile);
        const definition = await extractTypeDefinition(sourceFilePath, typeName);
        if (definition) {
            outputContent += definition + '\n\n'; // Add extracted type and spacing
            typesFound++;
        }
    }

    if (typesFound !== typesToExtract.length) {
        console.error("!!! Sync Failed: Not all types could be extracted. Please check warnings above. Target file not updated. !!!");
        process.exit(1); // Exit with error code
    }

    try {
        await fs.writeFile(TARGET_SHARED_TYPES_FILE, outputContent);
        console.log(`Successfully synced ${typesFound} types to ${path.relative(MONOREPO_ROOT, TARGET_SHARED_TYPES_FILE)}`);
    } catch (error) {
        console.error(`!!! Sync Failed: Could not write to target file ${TARGET_SHARED_TYPES_FILE}:`, error);
        process.exit(1); // Exit with error code
    }
}

main().catch(err => {
    console.error("!!! Unhandled error during type sync: ", err);
    process.exit(1);
}); 